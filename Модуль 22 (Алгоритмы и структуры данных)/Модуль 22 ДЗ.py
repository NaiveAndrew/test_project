# функция для сортировки списка по возрастанию
def sort_list(lst):
    # алгоритм сортировки выбором
    for i in range(len(lst)):
        idx_min = i
        for j in range(i, len(lst)):
            if lst[j] < lst[idx_min]:
                idx_min = j
        if i != idx_min:
            lst[i], lst[idx_min] = lst[idx_min], lst[i]
    return lst

# функция для двоичного поиска позиции элемента
def binary_search(lst, x):
    # начальные границы поиска
    left = 0
    right = len(lst) - 1
    # пока границы не сомкнутся
    while left <= right:
        # находим середину отрезка
        mid = (left + right) // 2
        # если элемент в середине равен искомому, возвращаем его индекс
        if lst[mid] == x:
            return mid
        # если элемент в середине меньше искомого, сдвигаем левую границу
        elif lst[mid] < x:
            left = mid + 1
        # если элемент в середине больше искомого, сдвигаем правую границу
        else:
            right = mid - 1
    # если не нашли элемент, возвращаем левую границу как ближайшую к искомому
    return left

# вводим последовательность чисел через пробел
seq = input("Введите последовательность чисел через пробел: ")
# преобразуем ее в список целых чисел
lst = list(map(int, seq.split()))
# вводим число для поиска позиции
x = int(input("Введите число для поиска позиции: "))
# сортируем список по возрастанию
lst = sort_list(lst)
# ищем позицию элемента с помощью двоичного поиска
pos = binary_search(lst, x)
# проверяем, что позиция не выходит за границы списка и что элемент слева от нее меньше искомого числа
if 0 <= pos < len(lst) and (pos == 0 or lst[pos - 1] < x):
    # выводим результат
    print(f"Позиция элемента, который меньше {x}, а следующий за ним больше или равен {x}, равна {pos}")
else:
    # выводим сообщение об ошибке
    print(f"В списке нет такого элемента, который меньше {x}, а следующий за ним больше или равен {x}")